# PROMPT 7: Creator Success & Seller Growth Toolkit

You are building a comprehensive seller growth and coaching system for the KTBlog digital product marketplace monorepo at `/Users/mac/codes/vivaexcel`. The tech stack is NestJS 11 backend (TypeORM, PostgreSQL, Redis, Anthropic AI SDK via `@anthropic-ai/sdk`, `@nestjs/schedule` for CRON, `@nestjs-modules/mailer` with Handlebars) and Next.js 16 frontend (React 19, Tailwind CSS 4, Framer Motion, TanStack React Query, Recharts, Lucide icons, next-intl for i18n). Sellers already have profiles (`apps/backend/src/entities/seller-profile.entity.ts` extending `BaseEntity` with UUID PK, `createdAt`, `updatedAt`, `deletedAt`), Stripe Connect integration (`apps/backend/src/modules/sellers/services/stripe-connect.service.ts`), payout management, and a seller dashboard at `apps/frontend/app/[locale]/seller-dashboard/` (with `page.tsx`, `layout.tsx`, and subdirectories for analytics, earnings, orders, products, settings). The existing `AiService` at `apps/backend/src/modules/ai/ai.service.ts` uses `Anthropic` client with model `claude-sonnet-4-5-20250929` and a `callClaude(systemPrompt, userMessage)` private method. The `MarketplaceAnalyticsModule` tracks `ProductView`, `ConversionEvent`, `RevenueRecord`, and `AnalyticsSnapshot` entities. The `SearchQuery` entity (`apps/backend/src/modules/search/entities/search-query.entity.ts`) logs all user searches with `query` and `resultCount`. The `EmailModule` is global, using `EmailService`. The `NotificationCenterModule` handles push notifications via `Notification`, `NotificationPreference`, `PushSubscription` entities. The `DigitalProduct` entity has `type` (POWERPOINT, DOCUMENT, WEB_TEMPLATE, etc.), `price` (decimal 12,2), `currency` (default USD), `categoryId`, `tags`, `title`, `description`, `seoTitle`, `seoDescription`, `seoKeywords`, `featuredImage`, `galleryImages`, `averageRating`, `viewCount`, `downloadCount`. The `SellerProfile` entity has `userId`, `totalSales`, `totalRevenue`, `averageRating`, `commissionRate`, `status`, `specialties`. Controllers follow the pattern of returning `{ status: 'success', message: string, data: T, meta?: PaginationMeta }`. Guards use `JwtAuthGuard` and `RolesGuard` with `@CurrentUser()` decorator extracting `JwtUserPayload` (with `sub` for userId and `email`).

## Implementation Steps

### Step 1 -- Create Entity Files for Seller Insights System

Create the following four entity files inside `apps/backend/src/entities/`:

**1a. `seller-insight.entity.ts`** -- Entity `seller_insights` extending `BaseEntity`. Columns: `sellerId` (uuid, indexed, FK to `seller_profiles.id`), `insightType` (enum `InsightType`: `PRICING`, `LISTING_QUALITY`, `MARKETING`, `PERFORMANCE`, `OPPORTUNITY`), `title` (varchar), `description` (text), `actionItems` (jsonb, typed as `Array<{ label: string; action: string; url?: string }>`), `priority` (enum `InsightPriority`: `HIGH`, `MEDIUM`, `LOW`), `status` (enum `InsightStatus`: `PENDING`, `VIEWED`, `ACTED_ON`, `DISMISSED`), `metadata` (jsonb, nullable, `Record<string, any>`), `generatedAt` (timestamp, default `NOW()`). Add `@ManyToOne(() => SellerProfile)` relation with `@JoinColumn({ name: 'seller_id' })`. Add composite index on `[sellerId, status]` and index on `generatedAt`.

**1b. `seller-goal.entity.ts`** -- Entity `seller_goals` extending `BaseEntity`. Columns: `sellerId` (uuid, indexed, FK to `seller_profiles.id`), `type` (enum `GoalType`: `REVENUE`, `SALES`, `PRODUCTS`, `RATING`), `title` (varchar, nullable -- for display), `targetValue` (decimal 12,2), `currentValue` (decimal 12,2, default 0), `deadline` (timestamp), `status` (enum `GoalStatus`: `ACTIVE`, `ACHIEVED`, `MISSED`, `CANCELED`, default `ACTIVE`). Add `@ManyToOne(() => SellerProfile)` relation. Index on `[sellerId, status]`.

**1c. `market-benchmark.entity.ts`** -- Entity `market_benchmarks` extending `BaseEntity`. Columns: `productType` (enum reusing `DigitalProductType` from `digital-product.entity.ts`), `categoryId` (uuid, nullable, FK to `digital_product_categories.id`), `averagePrice` (decimal 12,2), `medianPrice` (decimal 12,2), `priceRange` (jsonb typed as `{ min: number; max: number }`), `averageRating` (decimal 3,2), `averageSalesPerMonth` (decimal 12,2), `topSellerMetrics` (jsonb typed as `{ avgPrice: number; avgRating: number; avgMonthlySales: number }`), `sampleSize` (int), `calculatedAt` (timestamp, default `NOW()`). Unique composite index on `[productType, categoryId]`.

**1d. `seller-resource.entity.ts`** -- Entity `seller_resources` extending `BaseEntity`. Columns: `title` (varchar), `slug` (varchar, unique, indexed), `type` (enum `ResourceType`: `TUTORIAL`, `GUIDE`, `VIDEO`, `BEST_PRACTICE`, `SUCCESS_STORY`), `content` (text -- rich HTML from Tiptap), `excerpt` (varchar, nullable), `videoUrl` (nullable), `thumbnailUrl` (nullable), `category` (varchar, nullable -- e.g., "pricing", "marketing", "seo"), `tags` (simple-array, nullable), `order` (int, default 0), `isPublished` (boolean, default false), `publishedAt` (timestamp, nullable).

### Step 2 -- Create the SellerGrowth Module (Backend)

Create `apps/backend/src/modules/seller-growth/` with standard NestJS module structure:

**2a. `seller-growth.module.ts`** -- Import `TypeOrmModule.forFeature([SellerInsight, SellerGoal, MarketBenchmark, SellerResource, SellerProfile, DigitalProduct, DigitalProductCategory, RevenueRecord, ProductView, ConversionEvent, SearchQuery])`. Import `AiModule`, `EmailModule`, `NotificationCenterModule`, `ScheduleModule`. Register all controllers and services. Export key services.

**2b. `services/pricing-optimizer.service.ts`** -- Injectable service. Method `analyzePricing(sellerId: string, productId: string): Promise<PricingAnalysis>`. Steps: (1) load the product with category and tags, (2) query `MarketBenchmark` for matching `productType` and `categoryId`, (3) query all published products in the same category/type to get price distribution, (4) call `AiService.callClaude()` (make `callClaude` protected or add a new public `generateJSON` method on `AiService`) with a system prompt instructing it to return JSON with `suggestedPrice`, `priceRange`, `reasoning`, `competitivePosition` ("underpriced"/"competitive"/"overpriced"), and `confidenceScore` (0-100). Pass product details (title, description word count, image count, tag count, current price, rating) and benchmark data as user message context. Return typed `PricingAnalysis` DTO. Method `bulkAnalyzePricing(sellerId: string): Promise<PricingAnalysis[]>` -- analyze all published products for a seller, limit to 20 per batch.

**2c. `services/listing-scorer.service.ts`** -- Injectable service. Method `scoreProduct(productId: string): Promise<ListingScore>`. Score 0-100 based on six weighted dimensions: `titleQuality` (15 points -- length 30-80 chars, includes keywords, no all-caps), `descriptionCompleteness` (25 points -- word count > 200, has formatting/headings, includes feature list), `imageQuality` (20 points -- has featuredImage, galleryImages count >= 3), `seoOptimization` (15 points -- seoTitle set, seoDescription set, seoKeywords length >= 3), `pricingCompetitiveness` (15 points -- compare against MarketBenchmark), `tagRelevance` (10 points -- has >= 3 tags, tags match category norms). Calculate each subscore deterministically in code (no AI needed for this). Then call `AiService` to generate `improvementSuggestions: Array<{ dimension: string; suggestion: string; impact: 'high' | 'medium' | 'low' }>` based on the raw scores and product data. Return `ListingScore` with `overallScore`, individual dimension scores, and `suggestions`.

**2d. `services/market-opportunity.service.ts`** -- Injectable service. Method `findOpportunities(sellerId: string): Promise<MarketOpportunity[]>`. Steps: (1) query `SearchQuery` for top 100 terms by frequency in last 90 days where `resultCount = 0` or `resultCount < 3`, (2) group by normalized query term and count occurrences as `searchVolume`, (3) cross-reference against existing published product titles/tags/descriptions (full-text search) to confirm gaps, (4) call `AiService` with the gap data and ask it to categorize each opportunity by potential (`HIGH`, `MEDIUM`, `LOW`), suggest a product type, and estimate demand. Return `MarketOpportunity[]` typed as `{ term: string; searchVolume: number; existingProducts: number; potential: string; suggestedProductType: string; reasoning: string }`. Cache results in Redis with key `seller-opportunities:${sellerId}` and 24-hour TTL.

**2e. `services/sales-forecasting.service.ts`** -- Injectable service. Method `forecast(sellerId: string, days: 30 | 60 | 90): Promise<SalesForecast>`. Steps: (1) query `RevenueRecord` for this seller's last 180 days of daily revenue, group by `period` date, (2) calculate a simple moving average (7-day window), (3) calculate month-over-month growth rate, (4) detect seasonal patterns by comparing same periods in prior months, (5) query `MarketBenchmark` for overall market trend, (6) project forward using `projectedDailyRevenue = movingAverage * (1 + growthRate) * seasonalMultiplier`. Return `SalesForecast` with `forecastDays`, `projectedRevenue`, `projectedSales`, `confidenceInterval` `{ low: number; high: number }`, `dailyProjections: Array<{ date: string; revenue: number }>`, and `assumptions: string[]`.

**2f. `services/seller-coaching.service.ts`** -- Injectable service injecting `PricingOptimizerService`, `ListingScorerService`, `MarketOpportunityService`, `EmailService`, `NotificationCenterService`. Method `generateWeeklyDigest(sellerId: string): Promise<void>` -- fetch seller profile with user relation, get top insight (highest priority PENDING insight), compute 7-day performance summary (revenue, sales count, average rating from `RevenueRecord`), pick one actionable tip based on lowest-scoring listing dimension, compose email using `EmailService.sendMail()` with template `seller-weekly-digest` (create Handlebars template at `apps/backend/src/modules/email/templates/seller-weekly-digest.hbs` with sections: greeting, performance summary table, top insight card, actionable tip, CTA button to seller dashboard). CRON job: `@Cron('0 9 * * 1')` (every Monday at 9 AM) -- query all active sellers, call `generateWeeklyDigest` for each with 500ms delay between calls. Method `notifyOpportunity(sellerId: string, opportunity: MarketOpportunity): Promise<void>` -- create a `Notification` via `NotificationCenterService` with type `SELLER_OPPORTUNITY`, link to `/seller-dashboard/market`.

**2g. `services/benchmark-calculator.service.ts`** -- Injectable service. CRON `@Cron('0 3 * * *')` (daily at 3 AM) method `recalculateBenchmarks(): Promise<void>`. For each combination of `DigitalProductType` and active `DigitalProductCategory`, query all published products, compute average price, median price, min/max, average rating, average monthly sales (from `RevenueRecord` in last 90 days divided by 3). Upsert into `MarketBenchmark` table. Log count of benchmarks updated.

### Step 3 -- Create Controllers

**3a. `controllers/seller-insights.controller.ts`** -- Route prefix `seller-growth/insights`. All endpoints guarded with `JwtAuthGuard`. `GET /` -- list insights for current seller (get seller profile via `user.sub`, paginate, filter by `status` and `insightType` query params). `PATCH /:id/status` -- update insight status (body: `{ status: InsightStatus }`), validate the insight belongs to the current seller. `POST /generate` -- trigger AI insight generation for current seller (calls pricing optimizer, listing scorer, opportunity finder, saves new `SellerInsight` records for each finding, returns the generated insights). Rate-limit this endpoint to 3 calls per hour per seller using `@Throttle({ default: { limit: 3, ttl: 3600000 } })`.

**3b. `controllers/seller-goals.controller.ts`** -- Route prefix `seller-growth/goals`. `POST /` -- create goal (body: `{ type, targetValue, deadline, title? }`), validate with class-validator Zod or DTO, set `sellerId` from JWT. `GET /` -- list current seller's goals, filter by `status` query param. `PATCH /:id` -- update goal (progress or cancel). `DELETE /:id` -- soft-delete. Automatic goal check: in the `BenchmarkCalculatorService` daily CRON, also run `checkGoalDeadlines()` -- find all `ACTIVE` goals past their `deadline`, compare `currentValue` vs `targetValue`, set status to `ACHIEVED` or `MISSED`, create insight for achieved goals ("Congratulations!") or missed goals ("Your revenue goal fell short by X -- here's what to try next").

**3c. `controllers/seller-resources.controller.ts`** -- Route prefix `seller-growth/resources`. Public `GET /` (paginate, filter by `type`, `category`, `isPublished: true`). Public `GET /slug/:slug`. Admin-only `POST /`, `PATCH /:id`, `DELETE /:id` for CMS management (guarded with `RolesGuard`, roles `ADMIN`, `SUPER_ADMIN`).

**3d. `controllers/market-analysis.controller.ts`** -- Route prefix `seller-growth/market`. `GET /benchmarks` -- list benchmarks, filter by `productType` and `categoryId`. `GET /benchmarks/:productType/:categoryId?` -- get specific benchmark. `GET /opportunities` -- get market opportunities for current seller. `GET /forecast` -- get sales forecast (query param `days: 30 | 60 | 90`, default 30).

### Step 4 -- Register Module and Create Migration

Add `SellerGrowthModule` to the `imports` array in `apps/backend/src/app.module.ts` (after `SellersModule`). Generate a TypeORM migration for the four new tables: `seller_insights`, `seller_goals`, `market_benchmarks`, `seller_resources` with all columns, indexes, enums, and foreign keys as specified.

### Step 5 -- Create Frontend Seller Dashboard Pages

All pages go under `apps/frontend/app/[locale]/seller-dashboard/`. They must be `"use client"` components using TanStack React Query for data fetching (`useQuery`/`useMutation` with the backend API base URL from environment). Use Recharts for charts, Framer Motion for transitions, Lucide icons throughout. Follow the existing layout pattern in `apps/frontend/app/[locale]/seller-dashboard/layout.tsx`. All pages must be bilingual (wrap user-facing text with `useTranslations('sellerDashboard')`).

**5a. `insights/page.tsx`** -- Fetch `GET /api/v1/seller-growth/insights`. Render a card grid of insights sorted by priority. Each card shows: priority badge (red HIGH, yellow MEDIUM, green LOW), insight type icon, title, description, action items as a checklist. "Fix Now" button on each action item that navigates to the relevant page or triggers an inline action. Status filter tabs (All, Pending, Viewed, Acted On). Dismiss button that calls `PATCH /insights/:id/status`. "Generate New Insights" button (calls `POST /insights/generate`, show loading skeleton).

**5b. `pricing-tool/page.tsx`** -- Form to select a product from the seller's published products (dropdown). On selection, call `GET /api/v1/seller-growth/market/forecast?productId=X` endpoint (or a dedicated pricing endpoint). Display: current price vs. suggested price in large text, market comparison bar chart (Recharts `BarChart` showing seller's price, average, median, top-seller average), competitive position badge, AI reasoning text block, "Apply Suggested Price" button (calls `PATCH /api/v1/digital-products/:id` to update price).

**5c. `listing-health/page.tsx`** -- Fetch all seller's products, display each as a card with a circular score gauge (0-100, color coded: red < 40, yellow 40-70, green > 70). Click to expand detailed scores per dimension with progress bars. Improvement suggestions listed as checkboxes. "Re-score" button per product. Overall portfolio health score at top.

**5d. `goals/page.tsx`** -- Top section: "Set a New Goal" form (goal type select, target value input, deadline date picker, submit button). Below: active goals as progress cards -- each showing a radial progress chart (Recharts `RadialBarChart`), target vs. current value, days remaining, status badge. Completed/missed goals in a collapsible archive section below.

**5e. `learn/page.tsx`** -- Fetch `GET /api/v1/seller-growth/resources`. Display as a tabbed layout (Tutorials, Guides, Videos, Best Practices, Success Stories). Each resource card shows thumbnail, title, excerpt, type badge. Click navigates to `learn/[slug]/page.tsx` which renders the full `content` HTML. Video resources embed the `videoUrl` in an iframe or video player.

**5f. `market/page.tsx`** -- Two sections: (1) Market Opportunities -- fetch from `GET /api/v1/seller-growth/market/opportunities`, display as cards with search volume badge, potential rating (HIGH/MEDIUM/LOW colored), suggested product type, reasoning, "Create Product" CTA linking to product creation form. (2) Market Benchmarks -- filterable table/grid showing benchmark data per category with Recharts `BarChart` for price distribution, `LineChart` for sales trends.

### Step 6 -- Update Seller Dashboard Layout Navigation

Edit `apps/frontend/app/[locale]/seller-dashboard/layout.tsx` to add navigation links for the six new pages: Insights, Pricing Tool, Listing Health, Goals, Learn, Market Analysis. Use Lucide icons: `Lightbulb`, `DollarSign`, `HeartPulse`, `Target`, `GraduationCap`, `TrendingUp` respectively. Add a badge count on the Insights link showing the count of PENDING insights (fetch via a lightweight API call or pass from layout data).

### Step 7 -- Dashboard Admin: Seller Success Metrics

Add to the existing admin dashboard (`apps/dashboard/`): a new page or section for seller success management. Include: (1) MarketBenchmark configuration table (view/edit benchmarks, trigger recalculation), (2) Seller performance overview table (all sellers with their listing health scores, revenue, active goals, last login), (3) Low-quality listing flags (products with listing score < 40, sorted worst-first, with "Notify Seller" action that creates an insight), (4) Aggregate seller success KPIs: activation rate (sellers who made first sale / total approved sellers), median time to first sale, 30-day seller retention rate (sellers with activity in last 30 days / sellers approved > 30 days ago).
