# PROMPT 8: Global Commerce, Multi-Currency & Tax Compliance

You are building a complete international commerce layer for the KTBlog digital product marketplace monorepo at `/Users/mac/codes/vivaexcel`. The tech stack is NestJS 11 backend (TypeORM, PostgreSQL, Redis via `apps/backend/src/shared/redis/redis.service.ts`, Stripe via `apps/backend/src/modules/stripe/stripe.service.ts`, `@nestjs/schedule` for CRON, `@nestjs-modules/mailer` with Handlebars templates) and Next.js 16 frontend (React 19, Tailwind CSS 4, Framer Motion, TanStack React Query, Recharts, Lucide icons, next-intl for en/ar locales). The existing `CurrencyProvider` at `apps/frontend/providers/currency-provider.tsx` supports 7 currencies (USD, EUR, GBP, SAR, BRL, QAR, NGN) with hardcoded static `EXCHANGE_RATES` object and a `convertPrice(priceInUSD)` method -- this must be replaced with real rates. The `CurrencySelector` at `apps/frontend/components/store/currency-selector.tsx` renders a Framer Motion dropdown with flag icons. Product prices are stored as USD in `DigitalProduct.price` (decimal 12,2) with `currency` column defaulting to `'USD'`. The `Order` entity (`apps/backend/src/entities/order.entity.ts`) has `subtotal`, `discountAmount`, `total` (decimal 12,2), `currency` (default USD), `billingEmail`, `billingName`, `metadata` (jsonb), `stripePaymentIntentId`, `stripeSessionId`. The `CheckoutModule` creates Stripe checkout sessions via `StripeModule`. The `ProductView` entity records visitor `country` (ISO-2, length 2) from request headers. All entities extend `BaseEntity` (uuid PK, `createdAt`, `updatedAt`, `deletedAt`). Controllers return `{ status: 'success', message: string, data: T }`. The `AppModule` at `apps/backend/src/app.module.ts` already imports `ScheduleModule.forRoot()`, `RedisModule`, `StripeModule`, `CheckoutModule`, `EmailModule` (global). The backend uses `ConfigService` for environment variables.

## Implementation Steps

### Step 1 -- Create Entity Files for International Commerce

Create these entity files in `apps/backend/src/entities/`:

**1a. `exchange-rate.entity.ts`** -- Entity `exchange_rates` extending `BaseEntity`. Columns: `fromCurrency` (varchar length 3, e.g., "USD"), `toCurrency` (varchar length 3, e.g., "EUR"), `rate` (decimal precision 12, scale 6 -- six decimal places for accuracy), `source` (enum `ExchangeRateSource`: `ECB`, `STRIPE`, `CUSTOM`), `fetchedAt` (timestamp, default `NOW()`), `expiresAt` (timestamp). Add unique composite index on `[fromCurrency, toCurrency, source]`. Add index on `expiresAt` for cache invalidation queries.

**1b. `regional-pricing.entity.ts`** -- Entity `regional_pricing` extending `BaseEntity`. Columns: `productId` (uuid, FK to `digital_products.id`, indexed), `country` (varchar length 2, ISO 3166-1 alpha-2), `currency` (varchar length 3), `adjustedPrice` (decimal 12,2), `pricingStrategy` (enum `PricingStrategy`: `EXCHANGE_RATE`, `PPP`, `CUSTOM`), `pppMultiplier` (decimal 5,3, nullable -- e.g., 0.600 for India), `isActive` (boolean, default true). `@ManyToOne(() => DigitalProduct)` with `@JoinColumn({ name: 'product_id' })`. Unique composite index on `[productId, country]`.

**1c. `tax-configuration.entity.ts`** -- Entity `tax_configurations` extending `BaseEntity`. Columns: `country` (varchar length 2, indexed), `region` (varchar nullable -- e.g., "CA" for California, "ON" for Ontario), `taxType` (enum `TaxType`: `VAT`, `GST`, `SALES_TAX`, `HST`, `NONE`), `rate` (decimal 5,3 -- e.g., 20.000 for 20% VAT), `stripeTaxCode` (varchar nullable -- e.g., "txcd_10000000" for general digital goods), `isDigitalService` (boolean, default true), `description` (varchar nullable -- e.g., "EU Digital Services VAT"), `isActive` (boolean, default true). Unique composite index on `[country, region, taxType]`.

**1d. `invoice.entity.ts`** -- Entity `invoices` extending `BaseEntity`. Columns: `orderId` (uuid, FK to `orders.id`, indexed, unique), `invoiceNumber` (varchar, unique, indexed -- auto-generated format "INV-YYYYMMDD-XXXXX" where XXXXX is a zero-padded sequential counter), `buyerName` (varchar), `buyerEmail` (varchar), `buyerAddress` (jsonb typed as `{ line1?: string; line2?: string; city?: string; state?: string; postalCode?: string; country: string }`), `buyerTaxId` (varchar, nullable -- e.g., EU VAT number), `sellerName` (varchar), `sellerTaxId` (varchar, nullable), `lineItems` (jsonb typed as `Array<{ productId: string; name: string; quantity: number; unitPrice: number; totalPrice: number }>`), `subtotal` (decimal 12,2), `taxAmount` (decimal 12,2), `taxRate` (decimal 5,3), `taxType` (enum reusing `TaxType`), `total` (decimal 12,2), `currency` (varchar length 3), `issuedAt` (timestamp, default `NOW()`), `pdfUrl` (varchar, nullable -- S3/B2 URL after generation). `@OneToOne(() => Order)` with `@JoinColumn({ name: 'order_id' })`.

### Step 2 -- Create the InternationalCommerceModule (Backend)

Create `apps/backend/src/modules/international-commerce/` with:

**2a. `international-commerce.module.ts`** -- Import `TypeOrmModule.forFeature([ExchangeRate, RegionalPricing, TaxConfiguration, Invoice, Order, OrderItem, DigitalProduct, SellerProfile])`. Import `RedisModule`, `StripeModule`, `EmailModule`, `MediaModule` (for S3 upload). Register all services and controllers. Export `ExchangeRateService`, `RegionalPricingService`, `InvoiceService`.

**2b. `services/exchange-rate.service.ts`** -- Injectable service injecting `RedisService`, `ConfigService`, TypeORM repositories. Primary method `fetchAndStoreRates(): Promise<void>` -- fetch from ECB daily reference rates XML feed at `https://www.ecb.europa.eu/stats/euroforeignex/eurofxref/html/eurofxref-graph-usd.en.html` (or use the structured XML at `https://www.ecb.europa.eu/stats/policy_and_exchange_rates/euro_reference_exchange_rates/html/index.en.html` -- actually use the ECB SDMX/CSV endpoint `https://data-api.ecb.europa.eu/service/data/EXR/D..EUR.SP00.A?lastNObservations=1&format=csvdata`). Simpler: use a free JSON API such as `https://api.frankfurter.app/latest?from=USD`. Parse response, store each currency pair as a row in `exchange_rates` with `source: ECB`, `expiresAt: now + 4 hours`. Support 30+ currencies: USD, EUR, GBP, CAD, AUD, NZD, JPY, CNY, INR, BRL, ZAR, AED, SAR, QAR, NGN, KES, GHS, EGP, TRY, SEK, NOK, DKK, CHF, PLN, CZK, HUF, MXN, COP, ARS, THB, SGD, MYR, IDR, PHP, KRW. CRON `@Cron('0 */4 * * *')` (every 4 hours). Method `getRate(from: string, to: string): Promise<number>` -- first check Redis cache key `exchange-rate:${from}:${to}` (TTL 4 hours), if miss query database for latest non-expired rate, if no rate found fall back to last known rate (most recent row regardless of expiry), cache and return. Method `convert(amount: number, from: string, to: string): Promise<number>` -- get rate, multiply, round to 2 decimal places. On module init, run `fetchAndStoreRates()` once to seed data.

**2c. `services/regional-pricing.service.ts`** -- Injectable service. Maintain a static `PPP_MULTIPLIERS` map (sourced from World Bank International Comparison Program data) for key developing markets: `{ IN: 0.28, NG: 0.35, KE: 0.32, GH: 0.30, EG: 0.25, PK: 0.24, BD: 0.23, VN: 0.30, PH: 0.35, ID: 0.30, BR: 0.50, MX: 0.45, CO: 0.35, AR: 0.30, ZA: 0.40, TR: 0.35, UA: 0.25, TH: 0.40, MY: 0.45 }`. Method `getAdjustedPrice(productId: string, country: string): Promise<{ price: number; currency: string; strategy: PricingStrategy; originalPrice: number }>`. Logic: (1) check `regional_pricing` table for a `CUSTOM` override for this product+country, (2) if not found, check for `PPP` entry, (3) if not found and the country is in `PPP_MULTIPLIERS`, calculate `adjustedPrice = product.price * PPP_MULTIPLIERS[country]`, ensure minimum price of $2.00 equivalent, store as `RegionalPricing` row with strategy `PPP`, (4) if country not in PPP list, use `ExchangeRateService.convert(product.price, 'USD', countryCurrency)` with strategy `EXCHANGE_RATE`. Method `setCustomPrice(productId: string, country: string, price: number, currency: string): Promise<RegionalPricing>` -- upsert into `regional_pricing` with strategy `CUSTOM`. Method `getCountryCurrency(country: string): string` -- static map of ISO-2 country codes to primary currency codes (e.g., `US: 'USD'`, `GB: 'GBP'`, `IN: 'INR'`, `NG: 'NGN'`, `BR: 'BRL'`, `SA: 'SAR'`, etc., cover 50+ countries).

**2d. `services/tax.service.ts`** -- Injectable service. Method `calculateTax(country: string, region: string | null, amount: number): Promise<{ taxAmount: number; taxRate: number; taxType: TaxType; stripeTaxCode: string | null }>`. Query `tax_configurations` for matching country+region. If no region-specific config, fall back to country-level. Return computed tax. Method `getStripeTaxCode(): string` -- return `'txcd_10000000'` (Stripe's code for general digital goods/services). Seed method `seedDefaultTaxConfigurations()` called on module init -- insert default rows for: EU countries (20-27% VAT), UK (20% VAT), US states with digital goods tax (varies), Canada (5% GST + provincial), Australia (10% GST), India (18% GST), Brazil (varies), South Africa (15% VAT), UAE/Saudi (5% VAT). Set `isDigitalService: true` for all.

**2e. `services/invoice.service.ts`** -- Injectable service injecting `MediaService` (for S3 upload), `EmailService`. Method `generateInvoice(orderId: string): Promise<Invoice>`. Steps: (1) load Order with items, user, and for each item load the DigitalProduct with its creator/seller, (2) generate `invoiceNumber` using format `INV-${yyyymmdd}-${zeroPad(sequentialCounter, 5)}` (query max existing invoice number for today, increment), (3) compute line items, subtotal, tax (from `TaxService`), total, (4) save `Invoice` entity, (5) generate PDF using `PDFKit` (`npm install pdfkit @types/pdfkit`) -- create a professional invoice PDF with: header (KTBlog logo URL, invoice number, date), buyer section, seller section, line items table with columns (Description, Qty, Unit Price, Total), subtotal row, tax row (with tax type label and rate percentage), total row, footer (payment reference, "Thank you for your purchase"), (6) upload PDF buffer to S3 via `MediaService` (key: `invoices/${invoiceNumber}.pdf`, content-type: `application/pdf`), (7) update `invoice.pdfUrl` with the returned URL, (8) send email to buyer with PDF attachment using `EmailService.sendMail()` with template `invoice` (create `apps/backend/src/modules/email/templates/invoice.hbs`). Method `getInvoiceByOrder(orderId: string): Promise<Invoice>`. Method `downloadInvoice(invoiceId: string): Promise<{ buffer: Buffer; filename: string }>` -- stream from S3.

### Step 3 -- Integrate with Checkout Flow

**3a. Modify `apps/backend/src/modules/checkout/checkout.service.ts`**: Before creating the Stripe checkout session, detect buyer country (from request IP via `geoip-lite` -- `npm install geoip-lite @types/geoip-lite` -- call `geoip.lookup(ip)?.country`). Look up regional pricing for each cart item via `RegionalPricingService.getAdjustedPrice()`. Set `currency` on the Stripe session to the buyer's local currency (Stripe supports 135+ currencies). Pass `automatic_tax: { enabled: true }` on the Stripe checkout session creation if `STRIPE_TAX_ENABLED` env var is `'true'`. Add `tax_id_collection: { enabled: true }` to allow EU buyers to enter VAT numbers. Store the detected country and currency in `order.metadata` as `{ buyerCountry, displayCurrency, exchangeRateUsed, pricingStrategy }`.

**3b. Post-checkout invoice generation**: In the Stripe webhook handler (in `apps/backend/src/modules/stripe/stripe.service.ts`), after processing `checkout.session.completed` event and marking order as completed, call `InvoiceService.generateInvoice(order.id)`. This should be async (fire-and-forget with error logging, not blocking the webhook response).

### Step 4 -- Create API Controllers

**4a. `controllers/exchange-rate.controller.ts`** -- Route prefix `international/exchange-rates`. Public `GET /` -- return all current rates (from Redis cache). Public `GET /convert` -- query params `amount`, `from`, `to`, return `{ originalAmount, convertedAmount, rate, from, to }`. Admin-only `POST /refresh` -- manually trigger rate refresh. Admin-only `POST /custom` -- set a custom exchange rate override (body: `{ fromCurrency, toCurrency, rate }`).

**4b. `controllers/regional-pricing.controller.ts`** -- Route prefix `international/pricing`. Public `GET /product/:productId` -- query param `country` (optional, auto-detect from IP if not provided), return adjusted price with strategy info. Seller-only `GET /product/:productId/all` -- return all regional pricing entries for a product (must own the product). Seller-only `POST /product/:productId/custom` -- set custom regional price (body: `{ country, price, currency }`). Admin-only `GET /ppp-multipliers` -- return the PPP multiplier map.

**4c. `controllers/tax.controller.ts`** -- Route prefix `international/tax`. Public `GET /calculate` -- query params `country`, `region`, `amount`, return tax calculation. Admin-only `GET /configurations` -- list all tax configs. Admin-only `POST /configurations` -- create/update tax config. Admin-only `DELETE /configurations/:id` -- deactivate.

**4d. `controllers/invoice.controller.ts`** -- Route prefix `international/invoices`. Authenticated `GET /order/:orderId` -- get invoice for an order (must be order owner). Authenticated `GET /:id/download` -- download PDF (stream response with `Content-Type: application/pdf`, `Content-Disposition: attachment; filename="INV-xxx.pdf"`). Admin-only `GET /` -- list all invoices (paginate, filter by date range, currency).

### Step 5 -- Register Module

Add `InternationalCommerceModule` to `imports` in `apps/backend/src/app.module.ts`. Add environment variables to `.env.example`: `STRIPE_TAX_ENABLED=true`, `ECB_RATE_API_URL=https://api.frankfurter.app/latest?from=USD`, `PPP_PRICING_ENABLED=true`, `PPP_MIN_PRICE_USD=2.00`. Generate TypeORM migration for the four new tables.

### Step 6 -- Enhance Frontend CurrencyProvider

**6a. Replace `apps/frontend/providers/currency-provider.tsx`**: Remove the hardcoded `EXCHANGE_RATES` object. Add state for `rates: Record<string, number>` initialized to `{}` and `ratesLoaded: boolean`. On mount, call `GET /api/v1/international/exchange-rates` via `fetch`, parse response, set `rates` state mapping each `toCurrency` to its `rate`. Expand `SupportedCurrency` type to include all 30+ currencies from the backend (or type it as `string` with a curated display list). Keep fallback static rates for SSR/loading state. Update `convertPrice` to use fetched rates. Add `detectedCountry` state: call `GET /api/v1/international/pricing/detect-country` on mount (or read from a cookie set by middleware), auto-set currency based on country. Export `detectedCountry` from context. Store selected currency in cookie (not just localStorage) for SSR access. Re-fetch rates every 4 hours using `setInterval`.

**6b. Update `apps/frontend/components/store/currency-selector.tsx`**: Group currencies by region in the dropdown (Americas, Europe, Middle East, Africa, Asia-Pacific). Show country flag emoji from a `countryToFlag(isoCode)` utility. Show the converted equivalent price next to each currency option (e.g., "EUR -- Euro (~$0.92)"). Add a search/filter input at the top of the dropdown for 30+ currencies.

**6c. Update product price display**: In all product card and product detail components, replace direct `${product.price}` rendering with `useCurrency().convertPrice(product.price)` formatted with `Intl.NumberFormat(locale, { style: 'currency', currency })`. If PPP pricing is active for the detected country, show the adjusted price with a small "Regional pricing" tooltip explaining the discount.

**6d. Update checkout page** (`apps/frontend/app/[locale]/checkout/`): Display prices in the detected/selected currency. Show a "Prices shown in {currency}" notice. If PPP pricing applies, show original USD price crossed out and the regional price. Pass `country` parameter to checkout API call.

**6e. Add invoice download to order history**: In the order detail/confirmation pages under `apps/frontend/app/[locale]/account/`, add a "Download Invoice" button that calls `GET /api/v1/international/invoices/order/:orderId/download` and triggers a file download. Show invoice number alongside order number.

### Step 7 -- Dashboard Admin: Commerce Management

Add to `apps/dashboard/`: (1) Exchange rate monitoring page -- table of all current rates with last-fetched timestamp, "Refresh Rates" button, ability to set custom rate overrides. (2) Regional pricing page -- grid view of products with per-country price overrides, bulk PPP toggle per country. (3) Tax configuration page -- editable table of all tax configs by country/region, toggle active/inactive, Stripe tax code assignment. (4) Invoice management page -- searchable/filterable table of all invoices with download links. (5) Revenue by currency Recharts `PieChart` on the main admin dashboard showing order totals grouped by `currency` from the `orders` table.
